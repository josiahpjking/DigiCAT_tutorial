<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.340">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>DigiCAT Tutorials - 4. DigiCAT Methods</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script>
function toggle_visibility(id1, id2) {
var e = document.getElementById(id1);
var f = document.getElementById(id2);
e.style.display = ((e.style.display!='none') ? 'none' : 'block');
if(f.classList.contains('fa-hand-o-right')) {
    f.classList.add('fa-hand-o-down')
    f.classList.remove('fa-hand-o-right')
} else {
    f.classList.add('fa-hand-o-right')
    f.classList.remove('fa-hand-o-down')
}
}
</script>

<script src="https://kit.fontawesome.com/120b08a6f5.js" crossorigin="anonymous"></script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./04_cfmethod.html">4. DigiCAT Methods</a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">DigiCAT Tutorials</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">DigiCAT Tutorials</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01_introcf.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">2. Introduction to Counterfactual Analysis</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02_howto_digicat.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">1. Using DigiCAT</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03_choosecf.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">3. Choosing a Method</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04_cfmethod.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">4. DigiCAT Methods</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05_missing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">5. Missing Data</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06_survey.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">6. Complex Survey Data</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07_further.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Acknowledgements &amp; Further reading</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#propensity-score-matching-psm" id="toc-propensity-score-matching-psm" class="nav-link active" data-scroll-target="#propensity-score-matching-psm">Propensity Score Matching (PSM)</a>
  <ul class="collapse">
  <li><a href="#selecting-matching-variables" id="toc-selecting-matching-variables" class="nav-link" data-scroll-target="#selecting-matching-variables">Selecting matching variables</a></li>
  <li><a href="#propensity-score-specification-and-estimation" id="toc-propensity-score-specification-and-estimation" class="nav-link" data-scroll-target="#propensity-score-specification-and-estimation">Propensity score specification and estimation</a></li>
  <li><a href="#matching-on-the-propensity-score" id="toc-matching-on-the-propensity-score" class="nav-link" data-scroll-target="#matching-on-the-propensity-score">Matching on the propensity score</a></li>
  <li><a href="#balance-checking" id="toc-balance-checking" class="nav-link" data-scroll-target="#balance-checking">Balance Checking</a></li>
  <li><a href="#outcome-model-fitting" id="toc-outcome-model-fitting" class="nav-link" data-scroll-target="#outcome-model-fitting">Outcome model fitting</a></li>
  </ul></li>
  <li><a href="#iptw" id="toc-iptw" class="nav-link" data-scroll-target="#iptw">IPTW</a>
  <ul class="collapse">
  <li><a href="#estimating-weights-for-ate" id="toc-estimating-weights-for-ate" class="nav-link" data-scroll-target="#estimating-weights-for-ate">Estimating weights for ATE</a></li>
  <li><a href="#balance-checking-1" id="toc-balance-checking-1" class="nav-link" data-scroll-target="#balance-checking-1">Balance Checking</a></li>
  <li><a href="#outcome-model-fitting-1" id="toc-outcome-model-fitting-1" class="nav-link" data-scroll-target="#outcome-model-fitting-1">Outcome model fitting</a></li>
  </ul></li>
  <li><a href="#non-bipartite-nbp-methods" id="toc-non-bipartite-nbp-methods" class="nav-link" data-scroll-target="#non-bipartite-nbp-methods">Non-bipartite (NBP) methods</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">4. DigiCAT Methods</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="propensity-score-matching-psm" class="level2">
<h2 class="anchored" data-anchor-id="propensity-score-matching-psm">Propensity Score Matching (PSM)</h2>
<p>The main steps in propensity score matching (PSM) are to: 1) decide on which matching variables to include 2) fit a propensity model including these variables to estimate propensity scores (reflecting their propensity to experience a treatment variable) each individual in the sample 3) match treated individuals and control individuals with similar propensity scores 4) fit an outcome model using the matched data.</p>
<section id="selecting-matching-variables" class="level3">
<h3 class="anchored" data-anchor-id="selecting-matching-variables">Selecting matching variables</h3>
<p>In order to successfully address confounding with PSM it is necessary to identify and include measures of all relevant confounders in the propensity model. It is also necessary to specify the correct functional form of relations between the matching variables and the treatment variable; an issue discussed in more detail later. Confounders are variables that are common causes of both treatment assignment and the outcome. For example, when aiming to estimate the impact of physical activity on mental health, a person’s gender might be a confounding factor as it might impact both physical activity levels and mental health outcomes. These confounders should be chosen based on theory and past research. There is no real way to test that all relevant confounders have been identified and measured, therefore, there is a strong reliance on subject matter knowledge when choosing matching variables. Drawing causal diagrams can help to lay out the hypothesised causal relations between treatment, confounders and outcome. Arguments have also been made for including variables in the propensity model that are related only to the outcome (not treatment) variable since this can increase power to detect the treatment effect. On the other hand, it has been shown that including variables related only to the treatment variable (not the outcome variable) can reduce power. It is critical to not include variables that might have been impacted by the outcome variable as this can induce seriously distort the treatment effects. For this reason, researchers often limit the selection of matching variables to those that occurred (or were measured) prior to the treatment. In practice, it may be difficult to identify and to have measures available of all possible relevant confounders, therefore, researchers tend to select a large number of potential confounders.</p>
</section>
<section id="propensity-score-specification-and-estimation" class="level3">
<h3 class="anchored" data-anchor-id="propensity-score-specification-and-estimation">Propensity score specification and estimation</h3>
<p>Propensity score models can and have been estimated using a wide variety of approaches. This could include (regularised) regression approaches, machine learning tree-based methods, such as CART, and ensemble tree-based methods such as random forest or gradient boosted machines. Other machine learning techniques such as support vector machines and neural networks are also possible choices. There are pros and cons to different methods and DigiCAT provides an implementation of a selection of complementary methods. Logistic regression is provided for its high interpretability and quick computation. Two tree-based machine learning methods: random forest and gradient boosted machines will also be implemented soon because they have good flexibility for approximating complex relations between matching variables and treatments.</p>
<p>Logistic regression has historically been by far the most popular method of estimating propensity scores. It and probit regression are method that can estimate the associations between a set of predictors and a binary (0 vs 1) outcome variable. This makes them suitable models for estimating propensity scores for binary treatments.</p>
<p>In a simple logistic regression with only one predictor, the probability that Y=1, which we could denote P(y_i), is predicted from a matching variables, which we could denote X_1, using the formula:</p>
<p><span class="math display">\[
P(y_i) = \frac{1}{1+e^{-(b_0 + b_1X_1)}}
\]</span></p>
<p><span class="math inline">\(e\)</span> refers to the exponential function and <span class="math inline">\(b_0+b_1 X_{1}\)</span> forms a linear combination with a constant <span class="math inline">\(b_0\)</span> and the coefficient <span class="math inline">\(b_1\)</span> which captures the effect of the predictor <span class="math inline">\(X_1\)</span>. This then generalises to a multiple logistic regression that can include many matching variables and their interactions.:</p>
<p><span class="math display">\[
P(y_i) = \frac{1}{1+e^{-(b_0 + b_1X_1 + b_2X_2 + ... + b_kX_k)}}
\]</span></p>
<p>Each <span class="math inline">\(b\)</span> coefficient captures the effect of one predictor which in the context of propensity score analysis represents the effect of each matching variable on the treatment, The model can be estimated using maximum likelihood estimation. The individual b coefficients are typically not of great interest in a propensity analysis context. Instead of key interest is the propensity score. For each individual, propensity scores are the scores predicted by the model based on the estimated b coefficients. That is the predicted <span class="math inline">\(P(y_i)\)</span> scores represented the predicted probability of having received the treatment. It is these scores that are used in subsequent stages of propensity score analysis for matching or to derive weights in IPTW.</p>
</section>
<section id="matching-on-the-propensity-score" class="level3">
<h3 class="anchored" data-anchor-id="matching-on-the-propensity-score">Matching on the propensity score</h3>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Nearest neighbour 1:1 matching
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Nearest neighbour matching refers to a type of matching method that uses what is called ‘greedy matching’. In this method, a treated case is selected and the most similar control unit is matched with it. If there are multiple equally similar control units then one of them is selected at random. Then, another treated case is selected and the most similar control unit to it and so on and so forth until no more matches are possible. The simplest form of nearest neighbour matching uses matching without replacement whereby once a control unit has been matched to a treated unit, it is no longer available for matching to further treated units.</p>
<p>Nearest neighbour matching is also used with ‘calipers’ applied. This restricts matches only to treated and control units that are within a specified level of similarity to each other. This restriction is referred to as the ‘caliper distance’ and it helps to control the amount of ‘imbalance’ allowed between the treated and control units after matching. When calipers are applied, not all treated units will necessarily find a match; for some, there may not be any control units available that are sufficiently similar. In general, studies have found that using a caliper with nearest neighbour matching is beneficial for getting less biases treatment effect estimates (e.g., Austin, 2014). However, others have cautioned against using too strict calipers as these can have detrimental effects. Specifically, it can change the interpretation of the treatment effect from the effect of the treatment on the treated to the ‘effect of the treatment on the treated who have similar-enough controls’. The treated who have similar-enough controls might not be very representative of the underlying relevant population. In DigiCAT we currently do not impose caliper restrictions</p>
</div>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Nearest neighbour K:1 matching
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Nearest neighbour k:1 matching (also known as ‘many to one’ matching) is when each treated case is matched to multiple control cases. The ‘k’ refers to the number of controls that get matched to each treated unit. K:1 matching is done to make more use of the available sample as compared to 1:1 matching. In 1:1 matching if a treatment is rare (e.g., 50 out of a sample of 1000 experience it) then 1:1 matching leads to a lot of the sample not being used on the analysis (in this case only 100 out of the 1000 would be used at most).</p>
<p>It is important to note that matching more controls to each treated unit should not logically give a more accurate estimate of the effect of treatment. Rather, the main benefit of k:1 matching is that it can increase the precision of the estimate of the treatment effect.</p>
<p>The availability of k:1 matching raises the question of how many controls to match to each treated unit. Austin (2010) frame this decision in terms of a variance-bias trade-off. Specifically they point out that if you increase the the number of control units you can increase the matched sample size and thereby the precision (this is the ‘variance’ part of the trade-off). However, this likely means that you have to match control units that are less similar to their corresponding treated units. This could make the estimate of the treatment effect less accurate (the ‘bias’ part of the trade-off). They found using a simulation study that 1:1 nearest neighbour matching gave the most accurate treatment effects. Balancing various considerations they recommended that for most researchers, 1;1 or 2:1 matching (I.e., matching each treated unit to either 1 or 2 control units) is likely to the best option.</p>
<p>DigiCAT offers k:1 nearest neighbour matching. A slider on the ‘balancing’ page allows you to select the number of controls you wish to match to each treated unit. Using k:1 matching might make sense if your treatment variable is quite rare within your sample. If you choose k:1 matching, we recommend you also try 1:1 matching and compare the results to see if your conclusions are similar.</p>
</div>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Optimal matching
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Optimal matching is a matching algorithm which creates matches based on the criterion of minimising the average dis-similarity within pairs of treated and control units. In this way it differs from nearest neighbour matching which does not necessarily optimise the overall within-pair differences. It may be helpful to check the balance achieved with optimal versus nearest neighbour matching and choose the approach that gives the best balance</p>
</div>
</div>
</div>
</section>
<section id="balance-checking" class="level3">
<h3 class="anchored" data-anchor-id="balance-checking">Balance Checking</h3>
<p>Balance checking refers to assessing whether after matching on the propensity score, treated and control units are sufficiently similar in their matching variable distributions. A large variety of methods of checking balance have been suggested. These include methods for looking at overall balance (i.e., a summary measure of balance across all matching variables) and methods for looking at balance in the individual covariates. As regards, individual covariates, originally this was done using statistical tests (e.g.&nbsp;a t-test or chi-square test); however, nowadays this is generally avoided since these tests depend on sample size. Instead, measures such as standardised mean differences (SMDs) are used to quantify bias, complemented with graphical displays. Previous studies have discussed potential SMD thresholds to decide whether balance is suitably met, with different authors proposing <span class="math inline">\(|.05|\)</span>, <span class="math inline">\(|.10|\)</span>, and <span class="math inline">\(|.25|\)</span>. It has also been noted that lower thresholds are needed for binary matching variables to be equivalent to continuous variables <span class="math inline">\(|.1|\)</span> for binary variables is roughly equivalent to <span class="math inline">\(|.25|\)</span> for continuous variables). However, which threshold a user prefers depends on what level of imbalance a user is willing to accept (also see the discussion on calipers). Irrespective, for transparency and to aid the interpretation of findings, it is good practice to present the SMDs for the covariates when writing up. Where there is some imbalance between the groups, adjusting for the matching variables in the outcome model can be helpful for addressing any bias due to this (see ‘outcome model’ section).</p>
<p>Both SMDs and graphical displays are implemented within DigiCAT and are provided after fitting the propensity model and implementing the matching. This allows you to inspect the quality of matches before proceeding to the outcome model. If the balance is poor, you may consider using a different method to try and get better balance. For example, you could try a different method of estimating propensity scores, switch from k:1 to 1:1 matching, or switch between nearest neighbour or optimal matching.</p>
<p>In terms of the output of the balancing stage DigiCAT, provides the common support graph which shows the distribution of propensity scores in the treatment and control group. When multiple imputation is used it shows the averaged distributions across all the imputed datasets. Ideally there should be a good amount of overlap between these two distributions, indicating that it is possible to identify a subset of the controls who are well-matched to the treated cases.</p>
<p>An observation table is also provided, which summarises the number of treated and control units before and after matching. It, therefore, shows the number of successful matches and the number of units that were discarded. The number of units are expressed in terms of the ‘effective sample size’ (ESS) which is relevant when there is weighting involved. This is because the number of cases might not in those cases be a good reflection of sample size.</p>
<p>Love plots are used to display the standardised mean differences between the treated and control groups before and after matching. The orange dots represent the difference before matching (I.e., unadjusted) while the blue dots represent the difference after matching. Ideally the latter dots should all be close to the zero line. Further, one would expect to see a reduction in the standardised mean difference after matching so that the blue dots should be closer to the zero line than the orange dots.</p>
<p>A balance table provides the standardised mean difference figures. Different researchers may be willing to accept different sizes of standardised mean differences (and this may differ across contexts) and there is no one right answer as to how big is too big. Commonly suggested thresholds for standardised mean differences include magnitudes of .10 and .25. Whichever threshold is chosen, however, it is recommended that these figures are reported (perhaps as Supplementary Materials) when writing up as they capture how successfully the treated and control groups have been balanced.</p>
</section>
<section id="outcome-model-fitting" class="level3">
<h3 class="anchored" data-anchor-id="outcome-model-fitting">Outcome model fitting</h3>
<p>The final step in the PSM analysis workflow is fitting the outcome model. This is actually often much simpler than estimating the propensity model. It involves fitting a linear regression model to the now-matched data with the treatment indicator as a predictor. There are also good arguments for including the matching variables in this model too. This is because it can increase the power to detect the treatment effect, help deal with remaining bias due to imperfect balancing of the treated and control groups, and address dependencies in the data due to the fact that the data are now matched. However, this might not deal with all potential bias due to remaining imbalance because the treatment might also interact with the matching variables (e.g., different genders might benefit more or less from a treatment). This means that it can be good practice to also include treatment by matching variable interactions in the outcome model too. When this is done, a ‘marginal effects’ method can be used to calculate the average treatment effect. This is done because the coefficient for the treatment effect in the regression model might not otherwise have a meaningful interpretation, due to the presence of the interactions in the model.</p>
<section id="marginal-effects" class="level4">
<h4 class="anchored" data-anchor-id="marginal-effects">Marginal effects</h4>
<p>Marginal effects provide an estimate of the difference between potential outcomes under treated and control conditions and are therefore very helpful for understanding the effect of a treatment in counterfactual analysis. In DigiCAT, marginal effects are offered for binary treatments (in PSM and IPTW) using a method known as G-computation. In general this works in the following way: the outcome model has been fit, the predicted score for each case is calculated setting treatment status = treated and treatment status = control. This provides predicted outcome values for each case for each potential outcome (i.e., as if treated and as if not treated). The mean of these estimated potential outcomes across all cases is then taken for treatment status= treated and treatment status = control. The difference between these two means gives the estimated treatment effect. For PSM where we estimate the ATT, only the potential outcomes are estimated for the treated group as the ATT is all about estimating the effect of a treatment on the treated. This means that only the contrast between the potential outcomes of the treated (not control) cases is of interest. The standard errors of the treatment effect are also calculated.</p>
</section>
</section>
</section>
<section id="iptw" class="level2">
<h2 class="anchored" data-anchor-id="iptw">IPTW</h2>
<p>Inverse propensity of treatment weighting (IPTW) is a counterfactual analysis approach that attempts to balance treated and control units through the use of weights. The first step is identical to propensity matching and involves fitting a propensity model to get propensity scores (see <a href="#propensity-score-specification-and-estimation">propensity model estimation</a> above). In this model, the treatment variable is predicted by the matching variables in a model such as a logistic regression. Those scores are then transformed to provide weights. The balance of the weighted groups is then checked. Finally, the weights are used in a weighted regression. These steps are discussed in more detail below.</p>
<section id="estimating-weights-for-ate" class="level3">
<h3 class="anchored" data-anchor-id="estimating-weights-for-ate">Estimating weights for ATE</h3>
<p>After a propensity model has been fit (as described earlier) the scores from that model are taken and transformed to weights for use in IPTW. Different weights can be derived to estimate the ATT versus the ATE but here we focus on the ATE which is what is currently implemented within DigiCAT. When estimating the ATE, weights are assigned to each case such that treated cases with a lower propensity of experiencing the treatment are up-weighted and control cases with a higher propensity of experiencing the treatment are up-weighted relative to other treated and control cases respectively. This is done by transforming the estimated propensity scores according to the formula:</p>
<p><span class="math display">\[
w_{i} = Z_{i}/ e_{i} + (1-Z_{i}) /(1-e_{i})
\]</span></p>
<p>where <span class="math inline">\(Z_{i}\)</span> indicates whether a case was treated or not and <span class="math inline">\(e_{i}\)</span> indicates the inverse of the propensity of receiving the treatment (based on the estimated propensity score). This means that a cases weight is the inverse of the probability of receiving the treatment they actually received. This weighting scheme helps to re-balance the treated and control groups, making them more similar to each other.</p>
</section>
<section id="balance-checking-1" class="level3">
<h3 class="anchored" data-anchor-id="balance-checking-1">Balance Checking</h3>
<p>After estimating the IPTW weights balance checking can be used to see if the weights successfully rebalanced the treated and control groups. This can be done by looking at the differences between the groups in their matching variables after they have been weighted through looking at group (treated versus control) mean differences and graphical displays. Though it is not a measure of balance it is also possible to see at this stage how the weighting affected the ‘effective sample size’ of the data. When there is not a lot of overlap in the propensity scores of the treated and control groups, the effective sample size could be reduced quite a lot relative to the raw sample size in the unweighted data because most cases will not be very informative for a balanced comparison.</p>
<p>In DigiCAT, at the balancing check stay the common support graph is shown for the propensity scores. This indicates the similarity of the treated and control groups with greater overlap in the distributions being desirable. For IPTW it also shows the initial and weighted effective sample sizes to provide information about the effect of weighting. Typically we would expect to see that the effective sample size is smaller than the original sample size after weighting. A love plot is also shown to provide a visualisation of the group differences before and after weighting. A reference line a zero or ‘no difference’ between the treated and control group is included. Ideally the blue dots representing the standardised mean differences between the treated and control group for each matching variable should follow this zero line closely. They should also be closer to the zero line than the orange dots representing the standardised mean differences between the treated and control groups prior to matching. The values for the standardised mean differences before and after weighting are provided in the ‘Balance Table’ tab. As with propensity score matching there is no one agreed-upon magic threshold under which these values should be; however, the smaller the better and no more than .25 and ideally &lt; .05 or .10 are good figures to have in mind when judging balance.</p>
</section>
<section id="outcome-model-fitting-1" class="level3">
<h3 class="anchored" data-anchor-id="outcome-model-fitting-1">Outcome model fitting</h3>
<p>The final stage in IPTW is the outcome model fitting. This is achieved by incorporating the IPTW weights into a weighted regression model. The options are otherwise identical to those discussed under ‘outcome model fitting’ section for PSM.</p>
</section>
</section>
<section id="non-bipartite-nbp-methods" class="level2">
<h2 class="anchored" data-anchor-id="non-bipartite-nbp-methods">Non-bipartite (NBP) methods</h2>
<p>The majority of matching methods available, including the other methods described in DigiCAT, are ‘bipartite’, which is fitting for designs with only two treatment options (one treatment group and one control group). However, in practice you may encounter a scenario in which participants may receive multiple different treatments or have different dosages of a treatment. For example, participants may adhere to one of several treatments to stop smoking or drinking – standard care, self-help and counselling-guided intervention, interactive computer programs, or a combination of these. Another scenario may be if we are investigating the number of hours of social media consumption on anxiety, for example, or the number of hours of sleep on wellbeing – in which case, the treatment is on a continuous scale, rather than dichotomous. In order to determine causal inference in such situations, nonbipartite matching methods have been suggested in place of bipartite methods.</p>
<p>A common example where NBP is helpful is when the treatment variable is ordinal. This may be relevant if participants receive different dosages of a treatment and the question is ‘do cases that receive a higher dose have better outcomes than those who receive a lower dose?’ In this case if we imagine that there are three treatment groups: 0= control, 1= moderate dose, and 2= high dose and we can assume that the distance between 0 vs 1 and 1 vs 2 is equal (I.e., we have an ordinal treatment variable) we can match cases with treatment status 0 vs 1 and 1 vs 2 on their propensity score. This allows us to estimate the effect of moving from one treatment dosage to the next highest dosage.</p>
<p>We do this first by estimating propensity scores using an ordinal logistic regression model (which is suitable for ordinal outcomes) and then using those scores to match 0 vs 1 and 1 vs 2 cases. The matching is done using an optimal matching method (see ‘toptimal matching’). However, the particular implementation of this algorithm for NBP disallows matches between cases showing too much dissimilarity in their propensity scores. This is to enforce better balance between the treated and control groups.</p>
<p>After the matching of higher and lower dosage cases has taken place we then fit an outcome model using linear regression, similar to those in PSM and IPTW to the matched data. In this way the NBP workflow is very similar to the PSM workflow in DigiCAT, however, some differences should be highlighted that are a function of the fact that methods for ordinal treatments are less developed than methods for binary treatments. First, complex survey design variables are not yet implemented for these methods. Second, in the balancing output in the love plot, the matched sample standardised mean difference is displayed with the average difference across all pairwise matches. This makes it not completely analogous plots in the PSM and IPTW output. Finally, as marginal effects are not yet implemented for NBP, only two outcome model options are available: a linear regression with only the treatment variable as a predictor and a regression with the treatment variable and matching variables as covariates. This is because in the presence of treatment-matching variable interactions the regression coefficient for the treatment effect is not likely to be meaningful on its own (I.e., without computing marginal effects).</p>
<!-- ### Conceptually, how does nonbipartite matching work? -->
<!-- In the distance matrix tabulated below, we can imagine 6 different groups (termed 'nodes', in graph theory) that may be matched with one another. Some groups, such as 3 and 4, cannot be matched with one another, as the distance between them is an 'infinite distance'.   -->
<!-- Optimal matching would aim to create a matching consisting of 3 pairs, which the overall smallest total distance. Thus, matching result for the example below would be pairs of 1 and 6, 2 and 4, and 3 and 5, which would give a total overall distance of 30, the smallest achievable (10 + 10 + 10). Although, for instance, nodes 1 and 2 have an even smaller distance (of just 1), this would mean the remaining pairs to be matched would yield a greater overall distance, as node 6 would be left to match either with 4 or 5 (note it cannot be matched with 3 as it is of infinite distance), which have greater distances (100), and so the overall distance would not be the smallest possible.   -->
<!-- This is demonstrative of where optimal matching is superior to greedy matching, which would match nodes by proximity, but not consider overall distance and not yield the global optimal solution. In this instance, the 6 groups cannot be clustered into two, and therefore a nonbipartite algorithm should be used in place of bipartite algorithms.  -->
<!-- | Node | 1   | 2   | 3   | 4   | 5   | 6   | -->
<!-- | ---- | --- | --- | --- | --- | --- | --- | -->
<!-- | 1    | $\infty$   | 1   | $\infty$   | 2   | $\infty$  | 10  | -->
<!-- | 2    | 1   | $\infty$   | 2   | 10  | 100 | $\infty$   | -->
<!-- | 3    | $\infty$   | 2   | $\infty$   | $\infty$   | 10  | $\infty$   | -->
<!-- | 4    | 2   | 10  | $\infty$   | $\infty$  | 30  | 100 | -->
<!-- | 5    | $\infty$   | 100 | 10  | 30  | $\infty$  | 100 | -->
<!-- | 6    | 10  | $\infty$   | $\infty$   | 100 | 100 | $\infty$   | -->
<!-- Although nonbipartite matching can also be used with multiple unordered groups and time varying covariates, in DigiCAT it currently focuses on matching with multiple ordinal dose groups, specifically, and should not be interpreted as otherwise unless stated. In this scenario, the general steps would be as follows: first, generate propensity scores through an ordinal logit model, and then leverage these propensity scores to measure distances between participants. Following calculation of the distances, optimal nonbipartite matching would be performed to match participants possessing similar pre-treatment characteristics. Note, it is assumed that matching variables are the only variables that influence treatment assignment.   -->


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>